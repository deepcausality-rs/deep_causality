/*
 * SPDX-License-Identifier: MIT
 * Copyright (c) "2025" . The DeepCausality Authors and Contributors. All Rights Reserved.
 */

extern crate alloc;
use deep_causality_core::ControlFlowBuilder;
use deep_causality_core::{CausalProtocol, FromProtocol, ToProtocol};

// Strict Function 1: Sensor reading
// Input: bool - sets the sensor active
// Output: Vec<f64>
fn read_sensor(active: bool) -> Vec<f64> {
    if active { vec![1.0, 2.0, 3.0] } else { vec![] }
}

// Strict Function 2: Analysis
// Input: Vec<f64> - sensor reading
// Output: f64 - aggregated energy level
fn analyze_field(tensor: Vec<f64>) -> f64 {
    tensor.iter().sum()
}

// Strict Function 3: Safety Check
// Input: f64 - Energy level
// Output: bool - Returns true if energy < 100.0
fn check_safety(energy: f64) -> bool {
    energy < 100.0
}

fn main() {
    // We use the PhysicsProtocol below to type check correct input / output
    let mut builder = ControlFlowBuilder::<PhysicsProtocol>::new();

    // 1. Register Nodes
    // The builder infers types:
    // n1: NodeType<bool, Vec<f64>>
    // n2: NodeType<Vec<f64>, f64>
    // n3: NodeType<f64, bool>
    let n1 = builder.add_node(read_sensor);
    let n2 = builder.add_node(analyze_field);
    let n3 = builder.add_node(check_safety);

    // 2. Connect (Valid)
    // Connect read_sensor to analyze_field
    builder.connect(n1, n2); // Vec<f64> connects to Vec<f64>
    // Connect analyze_field to check_safety
    builder.connect(n2, n3); // f64 connects to f64

    // Invalid - Uncomment to see compiler error)
    // builder.connect(n1, n3);
    // ^ Error: ^^ expected `NodeType<Vec<f64>, _>`, found `NodeType<f64, bool>`
    // builder.connect(n2, n1);
    //  ^ Error: ^^ expected `NodeType<f64, _>`, found `NodeType<bool, Vec<f64>>`

    // 3. Build and Run
    let graph = builder.build();
    println!(
        "Graph built successfully with {} nodes.",
        graph.nodes().len()
    );

    // Execute the graph
    // Here demonstrate that the graph structure is correct, i.e. all connectors are type chaced,
    // the graph executes, and the result is the expected Signal(True).

    // Input is for the start node (read_sensor) and must be of type bool lifted into the protocol
    let input = true.to_protocol();

    // Pre-allocate queue for zero-allocation execution loop (Embedded requirement)
    use std::collections::VecDeque;
    let mut queue = VecDeque::with_capacity(10);

    match graph.execute(input, 0, 5, &mut queue) {
        Ok(result) => println!("Execution result: {:?}", result),
        Err(e) => println!("Execution failed: {}", e),
    }
}

//

// Example Protocol Enum
#[derive(Clone, Debug)]
pub enum PhysicsProtocol {
    Signal(bool),
    Tensor(Vec<f64>), // Simplified for demo
    Scalar(f64),
    Error(String),
}

impl CausalProtocol for PhysicsProtocol {
    fn error<E: core::fmt::Display>(msg: &E) -> Self {
        // In a real embedded system, we might log this to a ring buffer.
        // For the example, we can still allocate if we want, or store a static string.
        // Here we just format it to show it works, but the trait signature allows zero-alloc.
        use alloc::format;
        Self::Error(format!("{}", msg))
    }
}

// Boilerplate implementations (Can be generated by a macro)
impl ToProtocol<PhysicsProtocol> for bool {
    fn to_protocol(self) -> PhysicsProtocol {
        PhysicsProtocol::Signal(self)
    }
}
impl FromProtocol<PhysicsProtocol> for bool {
    type Error = &'static str;
    fn from_protocol(p: PhysicsProtocol) -> Result<Self, Self::Error> {
        match p {
            PhysicsProtocol::Signal(v) => Ok(v),
            _ => Err("Exp Signal"),
        }
    }
}

impl ToProtocol<PhysicsProtocol> for Vec<f64> {
    fn to_protocol(self) -> PhysicsProtocol {
        PhysicsProtocol::Tensor(self)
    }
}
impl FromProtocol<PhysicsProtocol> for Vec<f64> {
    type Error = &'static str;
    fn from_protocol(p: PhysicsProtocol) -> Result<Self, Self::Error> {
        match p {
            PhysicsProtocol::Tensor(v) => Ok(v),
            _ => Err("Exp Tensor"),
        }
    }
}

impl ToProtocol<PhysicsProtocol> for f64 {
    fn to_protocol(self) -> PhysicsProtocol {
        PhysicsProtocol::Scalar(self)
    }
}
impl FromProtocol<PhysicsProtocol> for f64 {
    type Error = &'static str;
    fn from_protocol(p: PhysicsProtocol) -> Result<Self, Self::Error> {
        match p {
            PhysicsProtocol::Scalar(v) => Ok(v),
            _ => Err("Exp Scalar"),
        }
    }
}
