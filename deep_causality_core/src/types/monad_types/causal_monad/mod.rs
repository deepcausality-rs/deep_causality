/*
 * SPDX-License-Identifier: MIT
 * Copyright (c) "2025" . The DeepCausality Authors and Contributors. All Rights Reserved.
 */

//! # Causal Monad
//!
//! This module defines the core monadic structure for handling causal effects within the
//! DeepCausality framework. It leverages Higher-Kinded Types (HKT) and the monadic pattern
//! to provide a robust, composable, and error-aware mechanism for propagating effects
//! through causal graphs and collections.
//!
//! The primary goal is to ensure that causal computations are:
//! - **Composable**: Effects can be chained together, with the output of one becoming
//!   the input of the next.
//! - **Error-aware**: Errors are propagated automatically, short-circuiting further
//!   computation in a controlled manner.
//! - **Log-preserving**: A complete history of operations and their outcomes is
//!   maintained for auditability and explanation.
//! - **Type-safe**: Leveraging Rust's type system to enforce correct usage and
//!   prevent common pitfalls in complex data flows.
//!
//! ## Monadic Operations
//!
//! The monadic pattern, as implemented here, provides two fundamental operations:
//!
//! 1.  **`pure(value)`**: Lifts a plain value into the monadic context. In this case,
//!     it creates a `CausalPropagatingEffect` containing the value, with no error
//!     and an empty log. This is the entry point for introducing a value into the
//!     causal effect system.
//!
//! 2.  **`bind(effect, f)`**: Chains a computation (`f`) to an existing `effect`.
//!     - If the `effect` contains an error, `bind` short-circuiting, propagating the
//!       error and the accumulated logs without executing `f`.
//!     - If the `effect` is successful, `bind` extracts its value, applies the
//!       function `f` (which itself returns a new effect), and then merges the
//!       logs from the original effect with the logs from the new effect.
//!       This ensures a continuous and complete log history.
//!
//! This design ensures that complex causal reasoning flows can be expressed clearly,
//! with built-in error handling and comprehensive logging, adhering to functional
//! programming principles within a performant Rust environment.
use crate::Intervenable;
use crate::{EffectLog, CausalEffectSystem, CausalPropagatingEffect, EffectValue};
use deep_causality_haft::{Effect3, Functor, HKT3, MonadEffect3, LogAppend, LogAddEntry};

/// `CausalMonad` is the concrete implementation of the `MonadEffect3` trait for the
/// `CausalEffectSystem`. It provides the fundamental `pure` and `bind` operations
/// that enable monadic programming within the DeepCausality framework.
///
/// This monad is designed to manage the flow of `CausalPropagatingEffect`s, ensuring
/// that errors are handled gracefully and a comprehensive log of operations is maintained.
///
/// ## `pure` function
///
/// `pure(value)` lifts a raw value `T` into the monadic context, creating a new
/// `CausalPropagatingEffect`. This effect starts with:
/// - The provided `value`.
/// - No error (`None`).
/// - An empty `CausalEffectLog`.
///
/// This is the entry point for any value that needs to enter the causal effect system
/// and participate in monadic computations.
///
/// ## `bind` function
///
/// `bind(effect, f)` is the sequencing operator of the monad. It takes an existing
/// `CausalPropagatingEffect` and a function `f` (which itself returns a new effect),
/// and orchestrates their execution:
///
/// 1.  **Error Short-circuiting**: It first checks if the `incoming_effect` already
///     contains an error. If so, `f` is *not* executed, and a new `CausalPropagatingEffect`
///     is immediately returned, carrying forward the original error and logs. The `value`
///     of the new effect is set to `U::default()` as the computation was aborted.
///
/// 2.  **Function Application**: If the `incoming_effect` is successful (no error),
///     its `value` is extracted and passed to the function `f`. The function `f`
///     then performs its computation and returns a `next_effect`.
///
/// 3.  **Log Aggregation**: The `logs` from the `incoming_effect` are combined with
///     the `logs` generated by the `next_effect` (from function `f`). This ensures
///     that the entire history of operations is preserved in the resulting effect.
///
/// The `bind` operation is crucial for building complex, sequential causal reasoning
/// pipelines where each step's outcome (value, error, and logs) correctly influences
/// the subsequent steps.
pub struct CausalMonad;

impl MonadEffect3<CausalEffectSystem> for CausalMonad
where
    <CausalEffectSystem as Effect3>::HktWitness:
        Functor<<CausalEffectSystem as Effect3>::HktWitness> + Sized,
{
    fn pure<T>(
        value: T,
    ) -> <<CausalEffectSystem as Effect3>::HktWitness as HKT3<
        <CausalEffectSystem as Effect3>::Fixed1,
        <CausalEffectSystem as Effect3>::Fixed2,
    >>::Type<T> {
        CausalPropagatingEffect {
            value: EffectValue::Value(value),
            error: None,
            logs: EffectLog::new(),
        }
    }

    fn bind<T, U, Func>(
        effect: <<CausalEffectSystem as Effect3>::HktWitness as HKT3<
            <CausalEffectSystem as Effect3>::Fixed1,
            <CausalEffectSystem as Effect3>::Fixed2,
        >>::Type<T>,
        mut f: Func,
    ) -> <<CausalEffectSystem as Effect3>::HktWitness as HKT3<
        <CausalEffectSystem as Effect3>::Fixed1,
        <CausalEffectSystem as Effect3>::Fixed2,
    >>::Type<U>
    where
        Func: FnMut(
            T,
        ) -> <<CausalEffectSystem as Effect3>::HktWitness as HKT3<
            <CausalEffectSystem as Effect3>::Fixed1,
            <CausalEffectSystem as Effect3>::Fixed2,
        >>::Type<U>,
        U: Default,
    {
        if let Some(error) = effect.error {
            return CausalPropagatingEffect {
                value: EffectValue::Value(U::default()),
                error: Some(error),
                logs: effect.logs,
            };
        }

        let mut next_effect = f(effect
            .value
            .into_value()
            .expect("Monad binding on a non-error effect should contain a value"));
        let mut combined_logs = effect.logs;
        combined_logs.append(&mut next_effect.logs);
        next_effect.logs = combined_logs;
        next_effect
    }
}

impl Intervenable<CausalEffectSystem> for CausalMonad {
    fn intervene<T>(
        effect: CausalPropagatingEffect<
            T,
            <CausalEffectSystem as Effect3>::Fixed1,
            <CausalEffectSystem as Effect3>::Fixed2,
        >,
        new_value: T,
    ) -> CausalPropagatingEffect<
        T,
        <CausalEffectSystem as Effect3>::Fixed1,
        <CausalEffectSystem as Effect3>::Fixed2,
    >
    where
        T: std::fmt::Debug, // Add Debug bound to log the new value
    {
        // 1. Preserve the incoming logs and add a new entry for the intervention.
        let mut new_logs = effect.logs;
        let log_message = format!("Intervention: Value replaced with {:?}", new_value);
        new_logs.add_entry(&log_message);

        // 2. Construct the new effect.
        CausalPropagatingEffect {
            // The value is replaced with the intervention value.
            value: EffectValue::Value(new_value),
            // The error state is preserved.
            error: effect.error,
            // The updated logs are carried forward.
            logs: new_logs,
        }
    }
}
