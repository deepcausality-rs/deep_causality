// SPDX-License-Identifier: MIT
// Copyright (c) "2025" . The DeepCausality Authors and Contributors. All Rights Reserved.

use crate::errors::CausalityError;
use crate::traits::intervenable::Intervenable;
use crate::types::effect_log::CausalEffectLog;
use crate::types::effect_value::EffectValue;
use crate::types::monad_types::causal_monad::CausalMonad;
use core::marker::PhantomData;
use deep_causality_haft::{LogAppend, Placeholder};

mod constructors;
mod display;
mod explain;
mod hkt;
mod predicates;

#[derive(Debug, PartialEq, Clone)]
pub struct CausalPropagatingEffect<Value, Error, Log> {
    pub value: EffectValue<Value>,
    pub error: Option<Error>,
    pub logs: Log,
}

impl<Value, Error, Log> CausalPropagatingEffect<Value, Error, Log>
where
    Value: Clone,
    Log: Clone,
{
    /// Enables fluent, chainable monadic operations on a `CausalPropagatingEffect`.
    ///
    /// This method takes ownership of the current effect and a function that transforms
    /// the inner value. It automatically handles error short-circuiting and log aggregation.
    ///
    /// # Arguments
    /// * `f`: A function that takes the current inner `EffectValue<Value>` and returns a new
    ///   `CausalPropagatingEffect` with a potentially different inner `EffectValue<NewValue>`.
    ///
    /// # Returns
    /// A new `CausalPropagatingEffect` that is the result of the sequenced operation.
    ///
    /// # Log Provenance
    /// This `bind` method is central to ensuring log provenance across monadic operations.
    /// It guarantees that the log history is always preserved and appended to, never overwritten.
    ///
    /// - If the current effect contains an error, its logs are passed through unchanged
    ///   to the returned effect, and the provided function `f` is not executed.
    /// - If there is no error, `bind` first captures the accumulated logs from the current effect.
    ///   It then executes the provided function `f`, which returns a new `CausalPropagatingEffect`
    ///   containing logs specific to its operation.
    /// - Finally, `bind` extends the accumulated logs from the current effect with the logs
    ///   generated by `f`, ensuring a complete and ordered history is carried forward.
    pub fn bind<F, NewValue>(self, f: F) -> CausalPropagatingEffect<NewValue, Error, Log>
    where
        F: FnOnce(EffectValue<Value>) -> CausalPropagatingEffect<NewValue, Error, Log>,
        NewValue: Clone + Default,
        Log: LogAppend + Default,
    {
        if let Some(error) = self.error {
            return CausalPropagatingEffect {
                value: EffectValue::default(),
                error: Some(error),
                logs: self.logs,
            };
        }

        let mut next_effect = f(self.value);
        let mut combined_logs = self.logs;
        combined_logs.append(&mut next_effect.logs);
        next_effect.logs = combined_logs;
        next_effect
    }
}

pub type PropagatingEffect<T, E, L> = CausalPropagatingEffect<T, E, L>;

impl<Value> PropagatingEffect<Value, CausalityError, CausalEffectLog>
where
    Value: Clone + core::fmt::Debug,
{
    /// Enables a fluent, chainable intervention in a monadic causal chain.
    ///
    /// This method takes ownership of the current effect and a new value,
    /// creating a counterfactual by replacing the effect's value while preserving
    /// its context (errors and logs).
    ///
    /// # Arguments
    /// * `new_value`: The new `Value` to force into the causal chain.
    ///
    /// # Returns
    /// A new `PropagatingEffect` with the value replaced, ready for the
    /// next step in the chain.
    ///
    /// # Log Provenance
    /// This method guarantees that the intervention is logged. It calls the underlying
    /// `CausalMonad::intervene` implementation, which is responsible for adding a
    /// specific log entry for the intervention before passing the effect along.
    pub fn intervene(self, new_value: Value) -> Self {
        CausalMonad::intervene(self, new_value)
    }
}

pub struct PropagatingEffectWitness<E, L>(Placeholder, PhantomData<E>, PhantomData<L>);
