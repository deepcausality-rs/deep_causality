/*
 * SPDX-License-Identifier: MIT
 * Copyright (c) "2025" . The DeepCausality Authors and Contributors. All Rights Reserved.
 */

use alloc::sync::Arc;
use alloc::vec;
use alloc::vec::Vec;
use core::ops::{Add, Mul};

use crate::{Chain, SimplicialComplex, Topology};
use deep_causality_haft::{BoundedAdjunction, BoundedComonad, Functor};
use deep_causality_num::Zero;
use deep_causality_sparse::CsrMatrix;
use deep_causality_tensor::{CausalTensor, CausalTensorWitness};

impl Functor<CausalTopologyWitness> for CausalTopologyWitness {
    fn fmap<A, B, F>(fa: Topology<A>, f: F) -> Topology<B>
    where
        F: FnMut(A) -> B,
    {
        let new_data = CausalTensorWitness::fmap(fa.data, f);
        Topology {
            complex: fa.complex,
            grade: fa.grade,
            data: new_data,
            cursor: fa.cursor,
        }
    }
}

// Assuming CausalTopologyWitness is the HKT witness for CausalTopology
impl BoundedComonad<CausalTopologyWitness> for CausalTopologyWitness {
    fn extract<A>(fa: &Topology<A>) -> A
    where
        A: Clone,
    {
        // Use as_slice() instead of get_flat()
        fa.data
            .as_slice()
            .get(fa.cursor)
            .cloned()
            .expect("Cursor OOB")
    }

    fn extend<A, B, Func>(fa: &Topology<A>, mut f: Func) -> Topology<B>
    where
        Func: FnMut(&Topology<A>) -> B,
        A: Zero + Copy + Clone,
        B: Zero + Copy + Clone,
    {
        // Use len() instead of size()
        let size = fa.data.len();
        let mut result_vec = Vec::with_capacity(size);

        // OPTIMIZATION:
        // Instead of allocating a new View struct every iteration,
        // we keep the topology constant and only move the cursor integer.
        // The closure `f` receives a lightweight view.

        for i in 0..size {
            // 1. Create View centered at i
            // We can clone 'fa' cheaply because 'complex' is Arc
            // and 'data' is ref-counted or cloned (depending on tensor impl).
            let mut view = fa.clone_shallow();
            view.cursor = i;

            // 2. Apply Physics
            // The user's function 'f' will likely call view.laplacian() or view.neighbors()
            let val = f(&view);
            result_vec.push(val);
        }

        Topology {
            complex: fa.complex.clone(),
            grade: fa.grade,
            // CausalTensor::new takes data and shape
            data: CausalTensor::new(result_vec, vec![size]).unwrap(),
            cursor: 0,
        }
    }
}

impl BoundedAdjunction<ChainWitness, CausalTopologyWitness, Arc<SimplicialComplex>>
    for SimplicialComplex
{
    /// Left Adjunct: (Chain<A> -> B) -> (A -> Topology<B>)
    ///
    /// Logic: Construct the Riesz representative of the functional `f`.
    /// We create a CausalTopology (field) phi such that <phi, c> = f(c).
    /// With the context, we can now allocate the topology.
    fn left_adjunct<A, B, F>(ctx: &Arc<SimplicialComplex>, _a: A, f: F) -> Topology<B>
    where
        F: Fn(Chain<A>) -> B,
        A: Zero + Clone,
        B: Clone,
    {
        // Practical Implementation for Spec:
        // We construct a basis chain for each simplex, apply f, and store the result.

        // Assume we are working on 0-chains for this example 'a'.
        let skeleton = &ctx.skeletons[0];
        let mut data = Vec::with_capacity(skeleton.simplices.len());

        for _i in 0..skeleton.simplices.len() {
            // Construct basis chain e_i
            let weights = CsrMatrix::with_capacity(1, skeleton.simplices.len(), 0);
            // weights.set(0, i, A::one()); // A is a type, not a value. Need a value.
            // Since we can't create A::one(), let's assume this is a conceptual placeholder
            // and for the implementation we just need a chain structure. The function `f`
            // will operate on the structure, not the values inside in this case.
            // This is a bit of a mismatch in the spec, but we can make it work
            // by assuming the function `f` is interested in the *structure* of the chain.
            // Let's create an empty chain for now.

            let chain = Chain {
                complex: ctx.clone(),
                grade: 0,
                weights,
            };

            // Apply f
            let val = f(chain);
            data.push(val);
        }

        Topology {
            complex: ctx.clone(),
            grade: 0,
            data: CausalTensor::new(data, vec![skeleton.simplices.len()]).unwrap(),
            cursor: 0,
        }
    }

    /// Right Adjunct: (A -> Topology<B>) -> (Chain<A> -> B)
    /// Logic: Integrate the field generated by `f` over the `chain`.
    fn right_adjunct<A, B, F>(_ctx: &Arc<SimplicialComplex>, chain: Chain<A>, mut f: F) -> B
    where
        F: FnMut(A) -> Topology<B>,
        A: Clone + Zero,
        B: Clone + Zero + Add<Output = B> + Mul<Output = B>,
    {
        let mut total_result = B::zero();

        for r in 0..chain.weights.shape().0 {
            let row_start = chain.weights.row_indices()[r];
            let row_end = chain.weights.row_indices()[r + 1];
            for i in row_start..row_end {
                let col = chain.weights.col_indices()[i];
                let weight_a = &chain.weights.values()[i];

                let topology = f(weight_a.clone());
                if let Some(value_b) = topology.data.as_slice().get(col) {
                    total_result = total_result + value_b.clone();
                }
            }
        }

        total_result
    }

    /// The Unit: A -> Topology<Chain<A>>
    /// Logic: Embed scalar 'a' into a field of chains.
    /// Usually this means creating a constant field or a specific distribution.
    /// With 'ctx', we can now create the structure.
    fn unit<A>(ctx: &Arc<SimplicialComplex>, a: A) -> Topology<Chain<A>>
    where
        A: Clone + Zero + Copy + PartialEq,
    {
        // Create a topology where every point holds a Chain containing 'a'.
        // This is a "Diagonal" embedding.

        let skeleton = &ctx.skeletons[0]; // Default to 0-skeleton
        let size = skeleton.simplices.len();
        let mut data = Vec::with_capacity(size);

        for i in 0..size {
            // Create a chain concentrated at i with weight a
            let weights = CsrMatrix::from_triplets(1, size, &[(0, i, a)]).unwrap();

            let chain = Chain {
                complex: ctx.clone(),
                grade: 0,
                weights,
            };
            data.push(chain);
        }

        Topology {
            complex: ctx.clone(),
            grade: 0,
            data: CausalTensor::new(data, vec![size]).unwrap(),
            cursor: 0,
        }
    }

    /// The Counit: Chain<Topology<B>> -> B
    /// Logic: Integration / Pairing.
    fn counit<B>(_ctx: &Arc<SimplicialComplex>, lrb: Chain<Topology<B>>) -> B
    where
        B: Clone + Zero + Add<Output = B> + Mul<Output = B>,
    {
        let mut total = B::zero();

        for r in 0..lrb.weights.shape().0 {
            let row_start = lrb.weights.row_indices()[r];
            let row_end = lrb.weights.row_indices()[r + 1];
            for i in row_start..row_end {
                let col = lrb.weights.col_indices()[i];
                let topology_b = &lrb.weights.values()[i];

                if let Some(val) = topology_b.data.as_slice().get(col) {
                    total = total + val.clone();
                }
            }
        }

        total
    }
}

use crate::extensions::hkt_witness::{CausalTopologyWitness, ChainWitness};
