use alloc::sync::Arc;
use alloc::vec;
use alloc::vec::Vec;
use core::ops::{Add, Mul};

use crate::{Chain, SimplicialComplex, Topology};
use deep_causality_haft::BoundedAdjunction;
use deep_causality_haft::HKT;
use deep_causality_num::Zero;
use deep_causality_sparse::CsrMatrix;
use deep_causality_tensor::CausalTensor;

// 1. Define Witness Types for HKT
pub struct ChainWitness;
impl HKT for ChainWitness {
    type Type<T> = Chain<T>;
}

pub struct CausalTopologyWitness;
impl HKT for CausalTopologyWitness {
    type Type<T> = Topology<T>;
}

impl BoundedAdjunction<ChainWitness, CausalTopologyWitness, Arc<SimplicialComplex>>
    for SimplicialComplex
{
    /// Left Adjunct: (Chain<A> -> B) -> (A -> Topology<B>)
    ///
    /// Logic: Construct the Riesz representative of the functional `f`.
    /// We create a CausalTopology (field) phi such that <phi, c> = f(c).
    /// With the context, we can now allocate the topology.
    fn left_adjunct<A, B, F>(ctx: &Arc<SimplicialComplex>, _a: A, f: F) -> Topology<B>
    where
        F: Fn(Chain<A>) -> B,
        A: Zero + Clone,
        B: Clone,
    {
        // Practical Implementation for Spec:
        // We construct a basis chain for each simplex, apply f, and store the result.

        // Assume we are working on 0-chains for this example 'a'.
        let skeleton = &ctx.skeletons[0];
        let mut data = Vec::with_capacity(skeleton.simplices.len());

        for _i in 0..skeleton.simplices.len() {
            // Construct basis chain e_i
            let weights = CsrMatrix::with_capacity(1, skeleton.simplices.len(), 0);
            // weights.set(0, i, A::one()); // A is a type, not a value. Need a value.
            // Since we can't create A::one(), let's assume this is a conceptual placeholder
            // and for the implementation we just need a chain structure. The function `f`
            // will operate on the structure, not the values inside in this case.
            // This is a bit of a mismatch in the spec, but we can make it work
            // by assuming the function `f` is interested in the *structure* of the chain.
            // Let's create an empty chain for now.

            let chain = Chain {
                complex: ctx.clone(),
                grade: 0,
                weights,
            };

            // Apply f
            let val = f(chain);
            data.push(val);
        }

        Topology {
            complex: ctx.clone(),
            grade: 0,
            data: CausalTensor::new(data, vec![skeleton.simplices.len()]).unwrap(),
            cursor: 0,
        }
    }

    /// Right Adjunct: (A -> Topology<B>) -> (Chain<A> -> B)
    /// Logic: Integrate the field generated by `f` over the `chain`.
    fn right_adjunct<A, B, F>(_ctx: &Arc<SimplicialComplex>, chain: Chain<A>, mut f: F) -> B
    where
        F: FnMut(A) -> Topology<B>,
        A: Clone + Zero,
        B: Clone + Zero + Add<Output = B> + Mul<Output = B>,
    {
        let mut total_result = B::zero();

        for r in 0..chain.weights.shape().0 {
            let row_start = chain.weights.row_indices()[r];
            let row_end = chain.weights.row_indices()[r + 1];
            for i in row_start..row_end {
                let col = chain.weights.col_indices()[i];
                let weight_a = &chain.weights.values()[i];

                let topology = f(weight_a.clone());
                if let Some(value_b) = topology.data.as_slice().get(col) {
                    total_result = total_result + value_b.clone();
                }
            }
        }

        total_result
    }

    /// The Unit: A -> Topology<Chain<A>>
    /// Logic: Embed scalar 'a' into a field of chains.
    /// Usually this means creating a constant field or a specific distribution.
    /// With 'ctx', we can now create the structure.
    fn unit<A>(ctx: &Arc<SimplicialComplex>, a: A) -> Topology<Chain<A>>
    where
        A: Clone + Zero + Copy + PartialEq,
    {
        // Create a topology where every point holds a Chain containing 'a'.
        // This is a "Diagonal" embedding.

        let skeleton = &ctx.skeletons[0]; // Default to 0-skeleton
        let size = skeleton.simplices.len();
        let mut data = Vec::with_capacity(size);

        for i in 0..size {
            // Create a chain concentrated at i with weight a
            let weights = CsrMatrix::from_triplets(1, size, &[(0, i, a)]).unwrap();

            let chain = Chain {
                complex: ctx.clone(),
                grade: 0,
                weights,
            };
            data.push(chain);
        }

        Topology {
            complex: ctx.clone(),
            grade: 0,
            data: CausalTensor::new(data, vec![size]).unwrap(),
            cursor: 0,
        }
    }

    /// The Counit: Chain<Topology<B>> -> B
    /// Logic: Integration / Pairing.
    fn counit<B>(_ctx: &Arc<SimplicialComplex>, lrb: Chain<Topology<B>>) -> B
    where
        B: Clone + Zero + Add<Output = B> + Mul<Output = B>,
    {
        let mut total = B::zero();

        for r in 0..lrb.weights.shape().0 {
            let row_start = lrb.weights.row_indices()[r];
            let row_end = lrb.weights.row_indices()[r + 1];
            for i in row_start..row_end {
                let col = lrb.weights.col_indices()[i];
                let topology_b = &lrb.weights.values()[i];

                if let Some(val) = topology_b.data.as_slice().get(col) {
                    total = total + val.clone();
                }
            }
        }

        total
    }
}
